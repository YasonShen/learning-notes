String转int
int i = Integer.valueOf(my_str).intValue();
int i = Integer.parseInt(str);

int转String
1.) String s = String.valueOf(i);
2.) String s = Integer.toString(i); 
3.) String s = "" + i; 

String转char
使用 String.charAt( index ) 方法，返回在index位置的char字符。(返回值：char )
使用 String.toCharArray( ) 方法，将String 转化为 字符串数组。(返回值：char[] ) 

char转String
//1.效率最高得到一种方法
 String s = String.valueOf('c');

//2.将字符串数组转化为字符串
String s = String.valueOf(new char[] {'G','e','o','o','o'});

//3.用 Character 的 toString(char) 方法  ==>  实际上还是调用了String.valueOf(char)
String s = Character.toString('c');

//4.new 一个 Character 调用 toString()
String s = new Character('c').toString();

//5.直接用 空 String 拼接 'c'
String s = "" + 'c' ;
//第5种方法效率最低，因为String类是 final 属性
// "" + 'c' 时候需要创建新的 String 类 ，如果进行很多次拼接则要创建很多个类虚拟机栈可能会溢出 

char转int
1）char ch = '9';
if (Character.isDigit(ch)){  // 判断是否是数字
    int num = Integer.parseInt(String.valueOf(ch));
    System.out.println(num);
}  

2）char ch = '9';
if (Character.isDigit(ch)){  // 判断是否是数字
    int num = (int)ch - (int)('0');
    System.out.println(num);
}

int转char
int number = 9;
char cNumber= (char) (number+'0');
System.out.println("Number "+number+" to char is:"+cNumber);

int转Integer
Integer integer=new Integer(i);

Integer转String
String str ＝ Integer.toString(a);

Integer转int
int num=Integer.intValue();

String转BigDecimal
BigDecimal d_id = new BigDecimal(str);

char转Integer
char[] chars = {'1','2','3'};
Integer i = new Integer(chars[1] - '0');
System.out.println(i);
char转Integer类型数据记得做相应运算，不然得不到想要的值，此处若为new Integer(char[1])，会返回50，而不是想要得到的2

String转Integer
Integer integer=Integer.valueOf(str);


	public void arrayListTraversal(List<Integer> lists){
	/* 第一种遍历方式 */
	System.out.print("for循环的遍历方式：");
	for (int i = 0; i < lists.size(); i++) {
	  System.out.print(lists.get(i));
	}

	/* 第二种遍历方式 */
	System.out.print("foreach的遍历方式：")         
	for (Integer list : lists) {
	 System.out.print(list);
	}

	/* 第三种遍历方式 */
	System.out.print("Iterator的遍历方式：");
	for (Iterator<Integer> list = lists.iterator(); list.hasNext();) {
	 System.out.print(list.next());
	}
	}


java中char类型的Arraylist如何转化成一个string

import java.util.ArrayList;
import java.util.List;

public class ceshi2 {
public static void main(String[] args) {

    List<Character> li = new ArrayList<Character>();
    li.add('a');
    li.add('b');
    li.add('c');
    StringBuilder str = new StringBuilder();
    for (Character character : li) {// 对ArrayList进行遍历，将字符放入StringBuilder中
        str.append(character);
    }
    System.out.println("输出从ArrayList中的所有字符" + str.toString());

}

异或运算有以下三个性质。

任何数和 00 做异或运算，结果仍然是原来的数，即 a \oplus 0=aa⊕0=a。
任何数和其自身做异或运算，结果是 00，即 a \oplus a=0a⊕a=0。
异或运算满足交换律和结合律，即 a \oplus b \oplus a=b \oplus a \oplus a=b \oplus (a \oplus a)=b \oplus0=ba⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。


select student.* from student inner join score on student.id = score.sut_id where score.score > (

	select avg(score) from score where subject_id = 10001
	)

for (语句1; 语句2; 语句3)
  {
  被执行的代码块
  }

语句 1 在循环（代码块）开始前执行
语句 2 定义运行循环（代码块）的条件
语句 3 在循环（代码块）已被执行之后执行(这就是循环中的++i和i++结果一样的原因，但是性能不一样，稍后解释)

根据上面的for循环的语法定义 ++i 和 i++的结果是一样的，都要等代码块执行完毕才能执行语句3，但是性能是不同的。在大量数据的时候++i的性能要比i++的性能好原因：

i++由于是在使用当前值之后再+1，所以需要一个临时的变量来转存。
而++i则是在直接+1，省去了对内存的操作的环节，相对而言能够提高性能

Arrays.copyOfRange(array,start,end)  左闭右开
Collections.sort()